---
title: "URL入力⇨ブラウザに表示まで"
path: "from-typing-url-to-rendering-contents-in-your-browser"
date: "2022-02-11"
update: ""
hero_image: "./alina-grubnyak-ZiQkhI7417A-unsplash.jpg"
hero_image_alt: "network"
hero_image_credit_text: "Alina Grubnyak"
hero_image_credit_link: "https://unsplash.com/photos/ZiQkhI7417A"
tags: [infra,network,web]
---

## 動機
だいぶ擦られたお題ではあるのですが、、、
去年基本情報＆応用情報を受験して、4月にネットワークスペシャリストを受験してみる予定です。
そのために、「[ネットワークはなぜ繋がるのか 第二版](https://www.amazon.co.jp/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B-%E7%AC%AC2%E7%89%88-%E7%9F%A5%E3%81%A3%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84TCP-IP%E3%80%81LAN%E3%80%81%E5%85%89%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-%E6%88%B8%E6%A0%B9/dp/4822283119)」や「[マスタリングTCP/IP 入門編](https://www.amazon.co.jp/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0TCP-IP%E2%80%95%E5%85%A5%E9%96%80%E7%B7%A8%E2%80%95-%E7%AC%AC6%E7%89%88-%E4%BA%95%E4%B8%8A-%E7%9B%B4%E4%B9%9F/dp/4274224473/ref=sr_1_1?keywords=tcp%2Fip&qid=1644243733&s=books&sprefix=TCP%2Cstripbooks%2C167&sr=1-1)」などを読んでみたり、いわゆる試験対策の参考書である「[徹底攻略 ネットワークスペシャリスト教科書](https://www.amazon.co.jp/%E5%BE%B9%E5%BA%95%E6%94%BB%E7%95%A5-%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B9%E3%83%9A%E3%82%B7%E3%83%A3%E3%83%AA%E3%82%B9%E3%83%88%E6%95%99%E7%A7%91%E6%9B%B8-%E4%BB%A4%E5%92%8C4%E5%B9%B4%E5%BA%A6-%E5%BE%B9%E5%BA%95%E6%94%BB%E7%95%A5%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E6%A0%AA%E5%BC%8F%E4%BC%9A%E7%A4%BE%E3%82%8F%E3%81%8F%E3%82%8F%E3%81%8F%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89-ebook/dp/B09DK5MZXJ/ref=sr_1_2_sspa?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=2ENBSDXHJDVYG&keywords=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B9%E3%83%9A%E3%82%B7%E3%83%A3%E3%83%AA%E3%82%B9%E3%83%88+%E6%95%99%E7%A7%91%E6%9B%B8&qid=1644243967&sprefix=%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B9%E3%83%9A%E3%82%B7%E3%83%A3%E3%83%AA%E3%82%B9%E3%83%88+%E6%95%99%E7%A7%91%E6%9B%B8%2Caps%2C197&sr=8-2-spons&psc=1&spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExVjBEOVVPTElKV1RKJmVuY3J5cHRlZElkPUEwODQwOTEyMUpUNUkwWlowNDJCTyZlbmNyeXB0ZWRBZElkPUExQzlWMEtWREhZS1FFJndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==)」を読んでみたりしました。

せっかく勉強するからには、試験対策のためだけの勉強ではなく、実際に役に立つ知識＆教養を身につけたいと思い、過去問やり込みなどはギリギリまで行わない予定なのですが、勉強を進めて知っていることが増えていくに従い、詳細に気を取られ全体が見えなくなってきてしまっていました。

そこで、複数書籍を読んで、どんな知識が全体を通してあるのかなんとなくわかってきたところで「木を見て森を見ず」な状態を脱却するために一度全体の大きな流れを掴んでから、再度詳細を勉強した方が効率が良いのではないかと思いました。
そのため今回は**「URLがアドレスバーに入力されてからWebページが表示されるまで」**の流れをまとめていこうと思います。

## 構成
### ブラウザ⇨サーバーに届くまで
- URL解析
- リクエストメッセージ作成
- リクエストメッセージの送信
  - DNSサーバー問い合わせ
  - TCPコネクション確立
  - データの送信
- 【補足】IP担当処理詳細
  - ヘッダーの付与
  - LANアダプタがデジタル⇨アナログ変換を行う
  - ルーターに向けて信号を送信
- ルーター間を伝わりネットワークを通って、サーバーに届く

### サーバーがデータの受信⇨ブラウザがコンテンツを表示するまで
- サーバーが信号を受信する
  - ブラウザがデータ送信の際にとったアクションの逆
  - 信号から元のリクエストメッセージまで戻す
- サーバーアプリケーションがデータを受け取る
  - URI、HTTPメソッドなどの情報をもとに処理
- サーバーがレスポンスメッセージを作成してブラウザに送り返す
- ブラウザが信号を受信する
  - サーバーの受信動作と同じ
  - 信号から元のレスポンスメッセージまで戻す
- レスポンスヘッダーを確認して、必要であればコンテンツを処理
- （HTMLの場合）HTMLファイルを解析してOSにブラウザに表示するよう指示を出す
- （画像などがアル場合）画像ファイルを再度サーバーにリクエストする。
  - レスポンスが返ってきたら、再度OSに指示を出しブラウザに表示

<br/>
今回は、この順番でまとめていければと思います。

いきなり詳細に入ってしまうと、項目が多すぎて全体の流れの中でどこにいるのかがわからなくなってしまうので、最初に全体の流れを記載しました。詳細を読む中で、全体のどこにいるのかがわからなくなったら、再度この構成を見ていただければとお思います。

また、かといって大枠だけだと流石に中身がなさすぎるので、程よい塩梅を狙ってまとめていければと思います。

＊本来各大項目毎に本が何冊も書けるレベルで情報量が多いはずなので、今回はわかりやすくシンプルにするために、プロバイダが提供してくれているルーター＆ルーター間のやりとりは大幅に省いております。


<br/>
<br/>

URLを入力してから、サーバーにデータが届くまでの往路の説明をこれからしていきます。

## URL解析
アドレスバーにはURLではない検索文字列を打ち込むこともできるし、URLを打ち込むこともできます。そのため、まずはアドレスバーに打ち込まれた文字列を解析して、URLであれば続く処理を、文字列であれば検索ブラウザを呼び出す処理をしていきます。

実際にURLが打ち込まれた例を考えていきましょう。

[https://blog.shgnkn.io/from-typing-url-to-rendering-contents-in-your-browser/](https://blog.shgnkn.io/from-typing-url-to-rendering-contents-in-your-browser) という、このブログのURLがあります。このURL文字列は複数の要素で成り立っており、ブラウザ内部では以下のように分解されます。

`https:` プロトコルを表します。

`//` 後に続く文字列がサーバーの名前であることを表します。

`blog.shgnkn.io` サーバー名です。

`/from-typing-url-to-rendering-contents-in-your-browser/` データがあるパス名です。

<br/>
これらの情報をもとに、HTTPリクエストを作成したり、必要に応じて暗号処理モジュールを呼び出して暗号化をしたりしていきます。

また、この際に、対象リソースのキャッシュをブラウザが保有しており、サーバーにHTTPリクエストを送信する必要がない場合には、以下の手順は飛ばしてブラウザへのレンダリングを開始することができます。

## HTTPリクエストメッセージの作成
URLの解析が完了して、サーバーへの問い合わせが必要なことがわかったら、次はHTTPリクエストメッセージを作成していきます。

リクエストメッセージにはルールが決められており、それに従ってブラウザは以下のような形式のリクエストメッセージを作成していきます。

```
POST / /sample/samle.php HTTP / 1.1
・
・
・
<空白行>
<メッセージボディ>
```

最初の行がリクエストヘッダで、どのメソッドをどのリソースに対してどんなプロトコルでリクエストを出したいのか指定します。
その後複数行のメッセージヘッダーで、コンテンツの種類や圧縮の形式など、必要な情報を付与していきます。
メソッドがPOSTの場合には、メッセージヘッダーの後に１行空白行を開けてからメッセージボディが続きます。ここには、`/sample/samle.php`に渡したいデータなどを記載します。

リクエストメッセージのルールについて、詳しくはMDNの[HTTP メッセージ](https://developer.mozilla.org/ja/docs/Web/HTTP/Messages)をご確認ください。

## リクエストメッセージの送信
ブラウザはURLを解析して、HTTPリクエストメッセージを作成することまでできますが、メッセージをサーバーに向けて送信する機能は持ち合わせていません。

そのため、作成したメッセージをサーバーに向けて送信する作業はOSに依頼していきます。

OSが依頼を受け取ってからは、TCP/IPなどさまざまなプロトコルが共同で作業をしていくことになります。

全体の流れとしてはOSI参照モデルに沿って順番にデータが流れていくのですが、一部階層の異なるプロトコルが互いにやりとりをして進む処理もあるため、今回のまとめでは厳密に切り分けずに進めていきたいと思います。

### DNSサーバーへの問い合わせ
URLを解析して、宛先ドメインはわかりましたが、宛先IPアドレスはまだわかっていません。

ただし、ブラウザがドメインとIPアドレスのペアをキャッシュとして保有している場合には、DNSサーバーに問い合わせする必要がなくなるので、以下のプロセスは不要になります。

ブラウザがキャッシュを保有していない場合には、DNSサーバーと通信してドメインからIPアドレスに変換する必要があります。

その際に、DNSサーバーとの通信を実際に行うのが、SocketライブラリのDNSリゾルバです。イメージとしては、今回まとめているブラウザとサーバーの関係がDNSリゾルバとDNSとで成り立っていると考えていただけると分かりやすいかと思います。
Socketライブラリについて少し補足すると、SocketライブラリはOSに組み込まれているネットワークと通信するためのライブラリです。

DNSリゾルバがDNSに問い合わせを行い、ドメインからIPアドレスを取得するのですが、実際の通信はDNSリゾルバではなく、OS組み込みのプロトコル・スタックが行います。DNSリゾルバがリクエストメッセージを作成しDNSサーバーへの問い合わせをプロトコル・スタックに依頼するイメージです。

また、この際に「DNSサーバーのIPアドレスはどうやって調べるんだ？」という疑問が出るかと思うのですが、DNSサーバーのIPアドレスは、PCのTCP/IPの設定であらかじめ設定してあるので、特にどこかに問い合わせたりする必要がないのです。

ちなみに、DNSサーバーへの問い合わせはTCPではなくUDPで行われます。なぜなら、問い合わせに使うパケットは１つしかないので、万が一通信に失敗してもDNSサーバーからのレスポンスが返って来なかったら失敗と判断することが可能で、わざわざ面倒な接続手続きをしてTCPを活用するよりも効率が良いからです。

DNSサーバーは階層構造で世界中にたくさんあるので、自分が問い合わせしたドメインのIPアドレスが格納されているDNSサーバーに問い合わせるまでにはもう少し道のりがあるのですが、今回は簡略化のために詳細は割愛します。

### TCPコネクションの確立
宛先IPアドレスがわかったら、次は実際にサーバーに向けてHTTPリクエストメッセージを送信するための準備をしていきます。
ここでも、DNSサーバーに問い合わせを行った時のように、Socketライブラリを活用してOSのプロトコル・スタックを呼び出して実際の処理を行っていきます。

イメージとしては、データを流すためのパイプラインを通信の最初に確立して、そこにデータを流していくイメージです。
流れとしては、
- サーバーとクライアント双方でそれぞれソケットを作成する
- クライアント側のソケットからからサーバー側のソケットにパイプを伸ばす（ソケットを接続する）
- 実際のデータ送受信を行う
- 最後にパイプを外す

という流れになります。このパートでは、データの送受信の手前までそれぞれ詳細を見ていきます。

#### ソケット作成
ソケットは実態を持っているわけではなく、宛先IPアドレス、送信元IPアドレス、ポート番号などを保持しているメモリ領域にすぎません。
プロトコル・スタックはこれらの情報を確認して、どの宛先に対してデータを送信するのかなどを把握しています。

クライアント側、サーバー側ではそれぞれソケットが作成されるタイミングが異なります。

<br/>
【クライアント側】

Socketライブラリからsocketを呼び出して、socketがプロトコル・スタックを呼び出して、プロトコル・スタックがソケットを作成します。
ソケットを作成すると、ディスクリプタというソケットの識別子が生成されるので、ソケット内部に保存しておきます。

また、この際にデータの送受信で必要となるバッファメモリの確保も行っておきます。

<br/>
【サーバー側】

サーバーを立ち上げた際にクライアント側と同じ手順でソケットが作成されるようになっています。

ソケットを作成したら、接続待ち状態でクライアントからの接続依頼が来るのを待ちます。

#### ソケット接続
ブラウザはサーバーのIPアドレスなどの情報を持っていますが、プロトコル・スタックはそれらの情報を持っていません。

そのため、ソケット同士をSocketライブラリのconnectを呼び出すことで接続して、プロトコル・スタックに通信に必要な情報を知らせてやる必要があります。

サーバーも然りで、ソケットがあるだけではどのクライアントと接続したらいいのかわからないので、接続動作をする際に、クライアントからクライアントのIPアドレス＆ポート番号をサーバー側に知らせてやる必要があります。

本物のパイプのように物理的な何かを生成するわけではなく、このように、制御情報のやりとりを行うことをソケットの接続とよんでいます。

connectによる制御情報の一連のやりとりが「3 way handshake」と呼ばれているもので、流れは以下のようになります。
＊以降説明を省略していますが、Socketライブラリのメソッドを呼び出した際には、そのメソッドがプロトコル・スタックに実際の処理を依頼して、プロトコル・スタックが処理は行っていると解釈してください。

- アプリケーションがSocketライブラリのconnectを呼び出す
  - connectの呼び出し時にはディスクリプタ、サーバーIP、サーバーポート番号を渡す
- データ送受信動作の開始を示すヘッダーである、TCPヘッダーを作成
  - 送信元、宛先のポート番号を入れる。これでどことどこが通信するのかわかる
  - コントロールビットのSYNを１にする
  - その他もろもろ設定して、TCPヘッダーをIP担当部分に渡す。実際の通信はIP担当部分の仕事
- IP担当がネットワークにパケットを流して、サーバーのIP担当が受け取る
- サーバーのIP担当はTCP担当に渡して、TCPはTCPヘッダーの中身を見る。ポートを調べて、該当するソケットが見つかったら通信進行中状態にする
  - この際に、接続待ち状態のソケットにそのまま接続するのではなく、接続待ち状態のソケットをコピーしてコピーした新しいソケットとクライントのソケットを繋ぐ
    - サーバー側のソケットは、コピーして使い続けるので、常に80番ポート（変えている場合もあるが）を使い続けることになる
    - そのため、送信元＆宛先IPアドレス、送信元＆宛先ポート番号の４つで判断するようにしている
    - クライアント側は接続の都度異なるポート番号を割り当ててくるし、異なるクライアントならIPアドレスが異なるので正しく見極めることが可能
- サーバーのTCP担当はクライアントと同じように、送信元、送信先のポート番号、コントロールビットのSYNを１にする。ACK番号は初期シーケンス番号+1にする。但しコントロールビットのACKは１。ここがややこしいので注意。確認番号とコントロールビットは同じACKでも別もの。
- TCPヘッダーをIP担当に渡してネットワークに流す
- クライアントは受け取ったら、SYNが１かどうか確認。１なら接続成功なので、ソケットにサーバーのIP、ポート、などを記載して、接続完了を示す制御情報もソケットに書き込んでおく。
- サーバーにACKを１にしたTCPヘッダーを送り返して、接続完了を伝える。
- これでコネクションが確立された状態になり、データを流すことが可能。Socketライブラリのcloseを実行するまでコネクションは確立された状態になる。

今回の説明では、「IP担当」という言葉が複数回にわたって登場しましたが、この詳細は後ほど説明していきます。
ここでは、TCP/IPプロトコルを用いて制御情報のやりとりを行い、クライアント側、サーバー側それぞれのソケットに対して制御情報をセットしていく作業がソケット接続に当たるのだな。と理解していただければ結構です。

### データの送信
ソケットの接続が完了したら、アプリケーションに処理が戻ります。

次は、アプリケーションがSocketライブラリのwriteを呼び出し、送信データをプロトコル・スタックに渡してデータの送信処理が始まります。

プロトコルスタックは、データの中身をこの時点では知らず、ただサイズがわかっているだけです。

一定程度、送信用バッファにデータを貯めてから流すことで、効率の良い通信を行っています。

逆に、データサイズが大きすぎてでMSS（マックス送信できるデータ量、MTUからヘッダー分を引いたもの）を超えるものに関しては送信用バッファから分割して送信するようにします。

送信する際に、制御情報から送信元ポート番号や宛先ポート番号などを書き込んだTCPヘッダーを付与して、IP担当部分に渡す。

IP担当部分はIPヘッダーやイーサネットのMACヘッダーなどを付与して送信を行います。IP担当の処理は、ソケット接続を行った時と同じでやっていることは共通しているので、後ほどまとめて説明していきます。

#### TCPプロトコルは送受信の信頼性を担保している
TCPプロトコルは信頼性を担保して、他のプロトコルが信頼性のことは気にしなくても済むようにしているので、データを送信したら相手に正しくデータが届いているか確認したいです。具体的な方法としては、以下の手順で信頼性を担保しています。
<br/>

- データを送信する際に、シーケンス番号をTCPヘッダーに入れておく。
  - 通信開始から数えて何バイト目のデータを送るのかを記載した項目。サーバはシーケンス番号とパケットのサイズから何バイト目から始まるデータが何バイト届くのかがわかる。
  - この仕組みによって、受信側でパケットに抜けがないか確認することが可能になる。
- 受信側は、何バイト目まで受信完了したのかをTCPヘッダーのACKに書き込んで送信側に知らせる。
  - これで、送信側もどこまで正確に送ることができているのかわかる。
- ACKが正しく帰ってこなかったら再送するが、何回か再送してダメだったら諦めてアプリケーションにエラーを返す

＊シーケンス番号は１から始まるのではなく、乱数で設定されます。ソケット接続時に、シーケンス番号の初期値をクライアントで設定してTCPヘッダーに付与することでサーバー側に渡しています。

<br/>

＊例では１パケット送ったらACKが帰ってくるまで待って送信しましたが、実際にはウィンドウサイズ（サーバー側で受け取ったデータを貯めておける量）をサーバーから受け取ってそのサイズまではACKが帰ってこなくても連続してデータを送信できるようにしています。

こうすることでACKの返答待ちをしなくてもパケットを送信することができる＆ACKパケットが減ることで通信効率を上げることができます。

## 【補足】IP担当処理詳細
これまでの説明の中で「IP担当に依頼して〜」のような形でお茶を濁してきた部分の詳細を説明していきます。
ここまでお茶を濁してきた理由としては、IPプロトコル、正確にはIP以下のプロトコルで行っている通信はデータの中身や目的によらず共通で、基本的にはあるデータを目的地まで届けるということを行っているので、後からまとめて説明した方が全体の流れを追いやすいと考えたためでした。

<br/>

ここから、IP担当が行っていた処理の詳細を説明していきます。あくまでも、データを目的地まで届ける。ということをしている点を忘れないでください。

### IPヘッダーとMACヘッダーの付与
TCP担当からTCPヘッダーとデータを渡されたら、そこにIPヘッダーとMACヘッダーを付与していきます。
パケットを宛先に届けるにあたって、まだどこに届けたらいいのかがわからない状態です。そのため、IPヘッダーとMACヘッダーそれぞれの中に、最終的な宛先IPアドレスと、次にパケットを渡す先のMACアドレスを設定してどこにパケットを渡せばいいのか他の機器が判断することができる状態にする必要があるのです。

その後、ヘッダーが付与されたパケットはLANアダプタに渡されていきます。

【IPヘッダーの中身】
- 宛先IPアドレス
  - ソケット接続時（TCPコネクション確立時）にアプリケーションからソケットに渡していたものを付与します
- 送信元IPアドレス
  - プロトコルスタックに設定されているモノを付与
- その他情報
  - パケット長、生存時間、プロトコル(上位プロトコルで、TCPやUDPなどを表す番号)、フラグ(分割の可否)、フラグメントオフセット(分割されたパケットが元のデータのどこに位置しているか)など

【MACヘッダーの中身】
- 宛先MACアドレス
  - 宛先をもとに経路表からどのルータ(IPアドレス)にパケットを渡すべきか調べる
  - 宛先ルータのIPアドレスからARPを用いてMACアドレスを取得する
    - DNSサーバに問い合わせる時同様、キャッシュにあるかまず確認して、なかったら問い合わせる
- 送信元MACアドレス
  - LANアダプタに製造時に付与されている。
  - OS起動時に読み出してメモリに保存しておいて、その値をMACヘッダー作成時に付与する
- イーサタイプ
  - IP(0800)、ARP(0806)など上位プロトコルを表すための番号

### LANアダプタでデジタルデータを信号に変換
IPヘッダーとMACヘッダーを付与したことで、パケットをどこに届けたらいいのか宛先は分かるようになりました。

次は、ネットワークの中にデータを流して、宛先まで届けることができるように、デジタルデータを信号に変換して送信していきます。

この作業は、LANアダプタが担います。

LANアダプタはそれ単体では活用することができず、LANドライバと一緒になって初めて活用することができます。

LANドライバが動き出してから、デジタルデータを信号に変換して送信するまでの流れを追っていきます。

- OS起動時にLANアダプタを初期化する
  - イーサネットの送受信動作をコントロールする、LANアダプタ内のMAC回路にMACアドレスをセットする
    - LANアダプタのROMにMACアドレスが製造時に書き込まれているのでそれをセット
    - 宛先MACアドレスはこのMACアドレスを指している
- IPからパケットを受け取る
- LANドライバがIPから受け取ったパケットをLANアダプタ内のバッファメモリにコピーする
- MAC回路に送信コマンドを送って、そこから先はMAC回路が処理をする
- MAC回路はバッファメモリからデータを読み出して、イーサネットフレームの先頭にプリアンブルとスタート・フレーム・デリミタ、末尾にはFCSも付与
  - プリアンブルはデータ受信側がタイミングを図るため
  - スタート・フレーム・デリミタはどこから実際のデータが始まるのか受信側が判断するため
  - FCSはフレームのエラーを検知するため。
- MAC回路がプリアンブルの頭から１ビットずつデジタルデータを信号に変換して、PHYもしくはMAUという信号送受信部分に送る。
- 信号をPHYもしくはMAU回路がケーブルに送り出す形式に変換して送信。
  - イーサネットはケーブルの種類や伝送速度によって形式が異なるのだが、MAC回路は共通のところまで変換して残りはPHYもしくはMAU回路に任している。
  - 送信したら、あとはルーター間を辿ってネットワーク内を流れ、送信先まで届く。
- 送信時には受信信号が流れこんできていないかも確認している
  - ただ、エラーはほぼない＆あっても処理はTCPに任せているので、イーサネットは何もしない。
- 万が一流れ込んできていたらパケットが衝突するので送信を止める
  - 送信を止めたら、ジャミング信号を他の機器に流して、しばらく送信動作をストップ。待ち時間は、MACアドレスから乱数を生成して、他の機器と被らないようにする。

ここまでで、IP担当が行っていた送信処理をまとめてきました。

受信処理に関しては、サーバー側に関する説明の際にまとめますが、クライアント側が受信処理をする際でも流れは同じです。

## ルーター間を伝わり、ネットワークを通ってサーバーに届く
ルーター内の処理も、ルーター間をデータが伝わる部分も詳細を記載していくと膨大になるのですが、今回は大幅に簡略化してまとめていきたいと思います。

### ルータ内の処理
- クライアント側LANアダプタから送信された信号を受け取る
- 信号をデジタルデータに変換
- FCSをチェックしてデータにエラーがないか確認
- IPアドレスのネットワーク部を元にルーティングテーブルを参照して、次のルーターの宛先IPアドレスをアドレスを取得
- 必要であればパケットを分割する
- 宛先IPアドレスからMACアドレスを取得するために、ARPで問い合わせてMACアドレスを取得する
  - ARPキャッシュが残っていれば、キャッシュからMACアドレスを取得する
- ルーターのポート部分がLANアダプタと同様の働きをしてデジタルデータを信号に変換し、次のルーターに送信する

### ルーター間について
ルーター間は、回線事業者が引いたADSL回線などを通ってデータが流れています。
この部分でも本来はさまざまな処理が行われていますが、普段我々が直接操作したり意識したりする部分は少ないので、今回は割愛します。

<br/>

また、ルーター間を通ってサーバーに届くまでの間には、ファイヤウォールやロードバランサ、プロキシサーバー（キャッシュサーバー）、CDSなど、様々な技術が活用されており、それぞれセキュリティを高めたり、サーバーの負荷を分散したり、コンテンツ配信の速度を上げたりといった役割を持っています。
これらも今回は詳細を割愛します。

### サーバーが信号を受信
ここまでの長い道のりを経て、やっとサーバーが信号を受信します。


<br/>
<br/>

ここからは復路の説明です。

この先、サーバーが信号を受信してから、レスポンスを返して、ブラウザが画面にコンテンツを表示するまでを見ていきます。受信する際の処理はクライアントが送信処理をした際の逆になるものがほとんどなので、新しいことは多くありません。

## サーバーが信号を受信
受信時はクライアントからのデータ送信時とは逆の手順が取られます。
クライアント側がデータを受信する場合でも、サーバー側がデータを受信する場合でも処理内容は同じです。

### LANアダプタの処理
- PHYもしくはMAU回路が、プリアンプルをみてタイミングを取って、データを読み込む
- PHYもしくはMAU回路がMAC回路が処理できる形式に変換してMAC回路に渡す
- MAC回路がデジタルデータに変換して、バッファメモリに貯める
- データを全て受け取ったら、FCSの計算をする。
  - イーサネットフレームの末尾についているFCSと付き合わせてズレていたらパケットを捨てる
- MACアドレスが自分宛かどうかチェックし、異なる場合捨てる。自分ならバッファメモリに貯める
  - MAC回路の仕事は終了で、CPUに割り込みでデータの受信を通知する
  - 通知方法は、LANアダプタが拡張バススロットにある割り込み用の信号線に信号を送る
- CPUは今の仕事を止めて、割り込み処理用プログラムに切り替える
- CPUがLANドライバを呼び出しLANアダプタのバッファメモリに格納されたデータを取り出す
- LANドライバがMACヘッダーのタイプ・フィールドを確認して適切なプロトコルスタックにパケットを渡す

ここからは、LANアダプタの仕事ではなく、プロトコルスタックが処理する範囲です。

## IPでの処理

- (タイプフィールドが0800でIPと仮定) IP担当がIPヘッダーを調べる
  - フォーマットに誤りがないか確認
  - 宛先IPアドレスが自分のものか確認
    - エラーだったら、ICMPで通信相手にエラーを返す
    - サーバーの場合にはルーターと同じ中継機能を持つ場合があるので、その時には自分宛以外でのも中継する
- IPヘッダーのフラグを見ると、分割されているかどうかがわかる。
  - 分割されていた場合、IP担当の内部メモリに一時保管して他のデータと繋ぎ合わせる。
    - ID情報に同じ値を持つパケットが仲間
    - フラグメント・オフセットが該当パケットが同一ID値ないでどの位置にくるパケットかを表しているので、この情報をもとにデータを結合する
- データを結合したら、次のプロトコルをチェックして然るべき担当にデータを渡す
  - この際、IPヘッダーの宛先＆送信元IPアドレス、TCPヘッダーの宛先＆送信元ポート番号を調べて、該当するソケットを探してTCP担当を見つけている。

## TCPでの処理
- TCPヘッダーを調べる
  - SYNが１の接続依頼の場合には、接続処理をするが、以下はデータが送られてきている前提で話を進める
  - 該当するソケットにデータを渡し、TCPヘッダーの中身を調べる
    - シーケンス番号が正しいかどうかなど
- 前回受け取ったデータに繋げ、受信バッファに保存
- TCPヘッダにACKを１にして作成し、IP担当に依頼し受信動作成功をクライアントに伝える
- アプリケーションがreadを呼び出して待っているはずなので、受信バッファのデータがアプリケーションに取られたらTCP担当の処理は完了

### サーバーサイドアプリケーションの処理
- サーバーアプリがreadでソケットの受信バッファからデータを読む
- URIとHTTPメソッドなどを元に後続の処理を決定する
- サーバーサイドで処理したらwriteでクライアントにデータを送り返す
  - HTMLをそのまま返すこともあれば、パラメタやリクエストボディの内容をCGIプログラムに渡して動かして、処理結果を返すこともある
  - この際、IPアドレスやドメイン、ユーザ名＆パスワードなどでアクセス制御をかける場合もある
- できたデータはクライアントがリクエストメッセージを作成したのと同じ方法で、レスポンスメッセージを作成する
- Socketライブラリのwriteメソッドでプロトコルスタックを呼び出しクライアントに送り返す。
  - 送信先はソケットのディスクリプタで指定する。ソケットはIPアドレスなど、データを届けるのに必要な情報持っているのでディスクリプタを指定するだけでOK
  - この先の流れは、クライアントからサーバーまでデータが送信された際の流れと同じです。

## ブラウザがデータを受信
ブラウザがデータを受信してから、画面にコンテンツを表示するまでの流れを説明していきます。

- LANアダプタが信号からデータに変換して受信バッファに貯める
- プロトコルスタックが分割されたデータをまとめて元のレスポンスメッセージに戻してブラウザに渡す
  - この辺りはサーバーの受信動作と同じ
- レスポンスヘッダーフィールドにあるContent-Typeでコンテンツの種類が何か確認
  - text/htmlのように、主タイプ/サブタイプの組になっている
      - textの場合、charsetで文字コードも調べる
  - Content-typeはサーバー管理者が設定を間違えていたりすることがある。そのため、データの中身などから総合的に判断する機能をブラウザが持っていることも多い。これはブラウザによって異なる
- Content-Encodingも確認して、どんな方法で圧縮されているのか確認。必要に応じて元に戻す
- コンテンツの種類がHTMLの場合には、中身を解析
- OSが画面上にコンテンツを表示する機能を持っているので、OSに対してどこに何を表示するのかブラウザから指示を出す
- 画像データを示すファイルがHTMLに入っている場合、サーバーに問い合わせて画像を取得する
  - HTMLを取得したリクエストと同じ方法を画像に対しても１枚ずつ行う
    - そのため、大量に画像が設置されているwebサイトなどは全ての画像を表示するために何回も通信する必要があり時間がかかる
- JPEGなどは圧縮されているので、受け取ったら復元して、文章と同じくOSに依頼して表示する



e