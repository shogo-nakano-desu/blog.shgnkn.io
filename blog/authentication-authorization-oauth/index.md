---
title: ""
summary: ""
path: "authentication-authorization-oauth"
date: ""
update: ""
hero_image: "./.jpg"
hero_image_alt: ""
hero_image_credit_text: ""
hero_image_credit_link: ""
tags: []
---
GCPのリソースにアクセスしたり、Google APIにアクセスしたりといった実装をすることが直近多かったのですが、認証認可には[google-auth-library-nodejs](https://github.com/googleapis/google-auth-library-nodejs)を活用して、Google推奨の方式であるADC(Application Default Credentials)を用いて雰囲気で実装していました。

いまいち仕組みがわかっていなくても動くし、最低限セキュアな実装にはできていたのですが脱雰囲気実装をしたく、認証・認可及びOAuth 2.0について改めて調べ直したのでそのメモです。

## そもそも、認証・認可の違いは？

### 認証

「**誰が」**アクセスしてきているのかを確認したい。

認証だけが完了した段階では、アプリケーションにアクセスすることはできるが、ユーザーに紐づいて管理されているリソースにはアクセスできない状態。

例えば仮に、Twitterで認証は行えたが認可は行われていない状態ならば、パブリックなツイートを見ることはできるが、鍵アカのツイートや自分のツイート、DMなどは見ることができない状態。

### 認可

認可ではアクセスしてきた人がどのリソースに対しての権限を持っているのかを確認したい。

通常、認証で本人確認が完了したのちに認可が行われ、ユーザーが**リソースにアクセスする権限を持っているかどうか**を確認する。

先ほどのTwitterの例だと、認証後に認可を行いリソースに対するアクセス権を確認することで、自分のDMやフォローしている鍵アカのツイートは見ることができるようになるが、フォローできていない鍵アカのツイートや他人のDMは見ることができない。

### おまけ：HTTPステータスでの使い分け

HTTPステータスで400系エラーコードは不正なリクエストに対するエラーコードですが、その中でも認証認可は使い分けがされています。

### **401 Unauthorized | 認証失敗**

> HTTP **`401 Unauthorized`**
 は、有効な認証資格が不足していることによりリクエストが適用されないことを示すクライアントエラーのレスポンスコードです。
[401 Unauthorized - HTTP | MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Status/401)
>

### **403 Forbidden | 認可失敗**

> HTTP の **`403 Forbidden`**
 クライアントエラーレスポンスコードは、サーバーがリクエストを理解したものの、認証が拒否されたことを示します。

このステータスは `[401](https://developer.mozilla.org/ja/docs/Web/HTTP/Status/401)`に似ていますが、この場合は再認証しても結果は変わりません。アクセスは恒久的に禁止されており、リソースにアクセスする権限が不足しているなど、アプリケーションのロジックに結びついたものです。
[403 Forbidden - HTTP | MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Status/403)
>

＊MDNでは「認証が拒否されたことを示します。」と書かれているので、認可エラーではなく認証エラーじゃないか。と思ったのですが、続きの文言を解釈しググったところ、認可エラーで403を使うことが一般的であるようなので、403 Forbiddenを認可エラー時に使用すると捉えて問題なさそうです。

## Webアプリケーションにおける認証方式

認証認可は別物である。ということがここまででわかりました。

まずは世の中にはどんな認証方式があるのか見て行きたいと思います。

### Basic認証

ユーザーIDとパスワードの組みをBase64でエンコードしてAuthorizationヘッダーに詰めてサーバーに送信することで認証を行う方式です。

```jsx
//Base64エンコード後（実際にリクエストヘッダーに入っている値）
Authorization: Basic c2hnbmtuOm15cGFzc3dvcmQ=

//エンコードする前
Authorization: Basic shgnkn:mypassword
```

実装が楽なので活用されることが多いようですが、ユーザーIDとパスワードの組みをBase64でエンコードしているだけなので通信が傍受されてしまった場合ユーザーIDとパスワードがダダ漏れです。そのため、活用する際には基本的にSSL /TLS(HTTPS)で通信を暗号化して活用します。

### **Digest認証**

Basic認証と基本的には同じで、AuthorizationヘッダーにユーザーIDとパスワードの組みを詰めてサーバーに送信することで認証を行います。

Basic認証と異なる点としては、Authorizationヘッダーに情報を詰める前に、最初のレスポンスでサーバーから返ってきたランダムな文字列とクライアントで生成したランダムな文字列、ユーザーID、パスワードをハッシュ関数で暗号化してから詰めるので、セキュリティが向上しています。

平文がそのまま送られてしまうBasic認証よりはセキュアになっています。最新のブラウザはSHA-256に対応していますが、古いブラウザだとMD5にしか対応していない場合もあるのでその場合には注意が必要です。（MD5は既に脆弱性が見つかっているため非推奨です。）

### **Bearer認証**

OAuth 2.0 で保護されたリソースにアクセスする際にBearerトークンを用いる方式です。

今回はOAuth 2.0の学習をメインで行ったので、詳細は後ほど記載します。

### その他認証方式

今までBasic認証、Digest認証、Bearer認証は触れたことがあったのですが、今回認証方式にはどんなものがあるのだろうと調べた際に思ったよりも色々な種類があって驚きました。

詳細は触れませんが、[IANA](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)に記載されていた認証方式を列挙しておきます。

- HOBA
- Mutual
- Negotiate
- OAuth
- SCRAM-SHA-1
- SCRAM-SHA-256
- vapid

## OAuth 2.0

認証方式にどのようなものがあるのかは１つ前のパートで見てきました。

Bearer認証でOAuth2.0の話が登場しましたが、OAuth 2.0は認証方式を定めたプロトコルではなく、「アクセストークンの要求とその応答」を標準化したプロトコルです。